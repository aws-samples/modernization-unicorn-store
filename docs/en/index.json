[
{
	"uri": "/en/10-intro.html",
	"title": "What and Why",
	"tags": [],
	"description": "",
	"content": "Before you dive head first into running the labs, please spend few minutes perusing this section to find out what this content is and isn\u0026rsquo;t, what type of professional will benefit from using it, what is required for running lab modules of this workshop, and how to be productive and have fun.\n"
},
{
	"uri": "/en/10-intro/05-target-audience.html",
	"title": "Who this Workshop is For",
	"tags": [],
	"description": "",
	"content": "Anyone comfortable with Visual Studio or Jetbrains Rider is going to have easy time with this workshop. Proficiency with C# is quite important and familiarity with Amazon Web Services is beneficial too.\n.NET developers, especially those writing web applications, are those who will benefit most from using this workshop. You don\u0026rsquo;t have to be seasoned engineer though to learn from and enjoy this content: even an intermediate or an ambitious beginner should have no trouble working through the most labs.\nOther technical roles, like Architects, DevOps, Site Reliability Engineers, with some familiarity with .NET software development ecosystem, should also have easy time following lab steps and learning how a run-of-the-mill ASP.NET application can be modernized and rip the benefits of moving to the cloud.\n"
},
{
	"uri": "/en/20-cdk/10-overview.html",
	"title": "CDK Module Overview",
	"tags": [],
	"description": "",
	"content": " Welcome to the .NET AWS CDK module of the workshop!\nHow to Run This Site Locally Please use PowerShell or bash (GitBash) to run commands below. They will open this web site locally on your computer.\ngit clone https://github.com/vgribok/modernization-unicorn-store.git cd modernization-unicorn-store git checkout cdk-module ./docs/en/index.html Workshop Goals The goal of this lab is to guide participants through:\n Running an existing .NET CDK project locally to bootstrap application\u0026rsquo;s CI/CD pipeline infrastructure in AWS. Adding support for MySQL database to both ASP.NET application codebase, as well as to the existing infra-as-code C# CDK projects (one defining cloud CI/CD pipeline and another defining cloud application deployment environment). Creating app hosting cloud infrastructure in AWS by running hosting infra .NET CDK project from within the CI/CD pipeline. Stepping in debugger through the code of two .NET CDK projects to explore how a CDK project that is a couple notches more complex than a \u0026ldquo;Hello, World\u0026rdquo; looks like.\n  This workshop skips the part showing basics of creating a new CDK project and adding a few basic CDK Constructs, and instead focuses on somewhat more in-depth capabilities of the CDK, by providing higher-fidelity code samples implementing closer-to-real-life scenarios. This means that the lab will start with a couple of existing, but still pretty small CDK projects, and the lab flow focuses on modifying these existing projects rather creating new ones.\nThe aim of the lab is to help you learn how to take your cloud-unaware ASP.NET Core application and use C# to write code defining:\n CI/CD pipeline infrastructure in AWS cloud that builds and deploys the application. AWS cloud application deployment infrastructure, including an application hosting components and a database: Amazon Elastic Container Service (ECS Fargate) and Amazon Relational Database Service (RDS), respectively. RDS hosts a selection of popular relational databases like Aurora MySQL (HA), Aurora Postgres (HA), and SQL Server.   If you find yourself struggling with the lab or running into unexpected errors, you may skip ahead by checking out cdk-module-completed Git branch, where all changes required for adding MySQL support are already implemented.\n CKD Demystified  AWS Cloud Development Kit is a set of higher-level abstraction components built on top of the Amazon CloudFormation - an indispensible previous-generation infrastructure-as-code service, with the major difference that CDK lets programmers use most of their favorite programming languages, like C#, to generate CloudFormation templates while writing order of magnitude less code than with CloudFormation.\n CDK consists of a CLI and a set of libraries available for most popular programming languages. In the case of .NET CDK, the libraries are added via NuGet.\nA .NET CDK project is a Console app, generating AWS CloudFormation template. CDK CLI is a convenience tool making it possible to bypass direct contact with lower-level CloudFormation templates and related commands of AWS CLI.\n"
},
{
	"uri": "/en/10-intro/10-overview.html",
	"title": "What&#39;s Inside",
	"tags": [],
	"description": "",
	"content": " ASP.NET Application The foundation of every module here is an ASP.NET Core Unicorn Store web application. It is based on a well-worn ASP.NET Music Store sample app and thus should be fairly familiar to many participants.\nUnicorn Store is has design that should make most .NET developers very comfortable. It has MVC/Razor UI and MVC Controllers implementing business logic. Data Access components of the application employ Entity Framework Core and are written using code-first style, enabling easy switching of the DAL from using SQL Server to other RDBMS, including open-source databases like MySQL and PostgreSQL.\nCI/CD Pipeline and Deployment Environment Infra As Code All workshop modules feature AWS CI/CD pipeline infrastructure and deployment environment infrastructure expressed as AWS CDK based C# code, thus enabling an easy building and deployment of the application in AWS cloud.\n"
},
{
	"uri": "/en/20-cdk.html",
	"title": "AWS .NET CDK Lab",
	"tags": [],
	"description": "",
	"content": " Welcome to the Infrastructure-as-C#-Code!  This module covers several facets of modern application development, namely using the .NET flavor of the AWS Cloud Development Kit (CDK) for creating cloud-based CI/CD pipeline for building and deploying an ASP.NET application, as well as for creation of an application cloud deployment/hosting environment.\nLevel: 300 (not a \u0026ldquo;Hello, World\u0026rdquo;)\n "
},
{
	"uri": "/en/",
	"title": "ASP.NET Modernization Workshop",
	"tags": [],
	"description": "",
	"content": " This site comprises a set of workshop modules created to showcase how an ASP.NET application can be converted from being an IIS and SQL Server bound monolith into a modern cross-platform application capable of running in the cloud.\nPlease use either navigation arrows on each sides of the page, or the Table of Contents on the left, to move around and find material that is most useful for you.\nDisclaimer  Using AWS resources may result in resource usage and other charges if you are using your personal or corporate AWS accounts. Please be sure to clean up AWS resources after completing modules of this Workshop.\n "
},
{
	"uri": "/en/20-cdk/20-setting-up.html",
	"title": "Setting Up Dev Environment",
	"tags": [],
	"description": "",
	"content": " You may skip this page and move on to the next step if you are using Amazon-supplied VM image (AMI) at an Amazon event, with all tools installed and pre-configured.\nPre-Requisites  Either MS SQL Server (LocalDB version is perfectly suitable), or PostgreSQL, per Common Prerequisites. MySQL is required, as the goal of the module is to add MySQL support to the app. MySQL Workbench, a MySQL management UI console, is recommended.   For Windows Users Only:\n  Chocolatey package manager. The jq utility that parses JSON.  Checking Out Source Code In a directory of your choice, please run\ngit clone https://github.com/vgribok/modernization-unicorn-store.git git checkout cdk-module Building and Running Unicorn Store Application Locally  Open Visual Studio solution:\ncd modernization-unicorn-store UnicornStore.sln In VS Solution Explorer, click the Collapse All [-] icon to clean up the tree view and select UnicornStore.csproj as a Startup Project.\n Choose build configuration for your choice of RDBMS:\n     Build Configurations Notes      You can use either MS SQL Server or PostgreSQL as a database at this point in the lab flow. (MySQL is not yet available at this point as it\u0026rsquo;s a new RDBMS to add support for as a part of this lab.) When using SQL Server LocalDb, no application configuration setting changes are necessary. You may simply select \u0026ldquo;DebugSqlServer\u0026rdquo; build configuration from the drop-down and run the application. For PostgreSQL, please select \u0026ldquo;DebugPostgres\u0026rdquo; from the build configuration drop down in the IDE.    Application Configuration for PostgreSQL You may skip this section if you plan to use MS SQL Server as a RDBMS for the application.\nIf you choose PostgreSQL as application\u0026rsquo;s RDBMS, additional changes in application settings are needed for the application to connect to a database other than local SQL Server with integrated authentication.\n   Notes Secret Manger     Please open UnicornStore project Secret Manager by right-clicking on the project and selecting Manage User Secrets menu item. It will open secrets.json file in Visual Studio, where you can make changes as it was the appsettings.json file.  Changes made in \u0026ldquo;secrets.json\u0026rdquo; override values stored in the \u0026ldquo;appsettings.json\u0026rdquo; files at run time, without making any changes to the \u0026ldquo;appsettings.json\u0026rdquo;.     Application setting named UnicornDbConnectionStringBuilder represents properties from RDBMS-specific subclasses of the DbConnectionStringBuilder. Since the plan here is to use PostgreSQL, properties of the \u0026ldquo;UnicornDbConnectionStringBuilder\u0026rdquo; section will represent properties of the NpgsqlConnectionStringBuilder class.\n{ \u0026#34;DefaultAdminUsername\u0026#34;: \u0026#34;Administrator@test.com\u0026#34;, \u0026#34;DefaultAdminPassword\u0026#34;: \u0026#34;Secret1*\u0026#34;, \u0026#34;UnicornDbConnectionStringBuilder\u0026#34;: { \u0026#34;Password\u0026#34;: \u0026#34;\u0026lt;YOUR POSTGRES PASSWORD\u0026gt;\u0026#34;, } } Please replace the content of the \u0026ldquo;secrets.js\u0026rdquo; file open in the Visual Studio, with the code snippet above, and replace the value of the Password property with your local Postgres password. Don\u0026rsquo;t forget to save the file before moving on to the next section of the lab.\n"
},
{
	"uri": "/en/10-intro/20-prerequisites.html",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "  To successfully execute any module of this workshop, following common requirements need to be fulfilled, in addition to any module-specific requirements outlined in each module guide.\nIf you are taking this lab within the scope of an Amazon event, in many cases a remote VM with all necessary prerequisites will be made available to workshop participants, so you may skip this chapter altogether. (Mac users, to access remote Windows VM, please ensure you have Remote Desktop Client installed).\n Note to non-Windows users: since most modules are based on .NET Core version of the application, Mac and Linux users should have no trouble executing most modules. Mac users should be able to use either Visual Studio for Mac, or Jetbrains Rider as an IDE. Linux users should use Jetbrains Rider IDE. Also, some of the links below target Chocolatey - Windows package manager. Mac and Linux users could simply switch to Homebrew or yum/apt/etc package managers respectively.\n(Although it is possible to use just dotnet CLI for this workshop, for simplicity and efficiency sake we dare to assume that takers of this workshop focusing on software development already know how to install their most basic tools, so the workshop guide could skip IDE etc. installation steps boilerplate.)\nSoftware Required for Most Modules  .NET Core Framework 3.0. Visual Studio 2019 Community Edition or any other IDE capable of building and running Visual Studio solutions. An RDBMS like MySQL, PostgreSQL or MS SQL Server LocalDB, along with a corresponding management console, will be required for most modules. AWS account to run the lab in the AWS cloud. AWS CLI to interact with AWS services from your system. Git for pushing lab code to the cloud CI/CD pipeline for deployment. Node.js and AWS CDK for building infrastructure-as-code projects that are part of the solution, as well as for bootstrapping CI/CD pipeline infra into AWS cloud.    Please note that AWS SDK release cycle is very short as the team iterates on the service very aggressively, which results in rapid introduction of sometimes breaking changes that may not always follow SemVer guidelines. It\u0026rsquo;s worth treating CDK minor version as major to minimize confusion. To get the AWS CDK version to install, check the content of the \u0026ldquo;./infra-as-code/CicdInfraAsCode/src/appsettings.json\u0026rdquo; file, from the Git repo root, and look for the value of the CdkVersion property.\n The list above provides good baseline for required development environment. Some modules, however, will have additional requirements specified in the introduction section of each module.\n"
},
{
	"uri": "/en/20-cdk/30-running-app-locally.html",
	"title": "Running App Locally",
	"tags": [],
	"description": "",
	"content": " Starting Unicorn Store Web Application     Notes      Once you have prepared your development environment, what remains is to ensure that UnicornStore.csproj is selected as a startup project, to switch hosting from \u0026ldquo;IIS Express\u0026rdquo; to Console, as shown on the screenshot on the left, and start the application in the debug mode.    After debugging session has started, a command console window will open first with application console output in it, along with a web browser window, showing the home page of the Unicorn Store ASP.NET application.    Exploring and Testing Unicorn Store Web Application Functionality Unicorn Store is an emulation of an e-commerce web site implementing simplified product catalog, shopping cart and a checkout flow.\nAfter you have started the application, you should see the home page shown on the screenshot above. At the bottom of the screen you should see RDBMS type and database server address information.\nPlease add a few unicorns to the basket, and click the \u0026ldquo;Checkout \u0026gt;\u0026gt;\u0026rdquo; button at the top of the shopping cart page. You will be prompted to log in. Please use credentials saved in the \u0026ldquo;secrets\u0026rdquo; file at the previous step: \u0026ldquo;Administrator@test.com\u0026rdquo; for username, and \u0026ldquo;Secret1*\u0026rdquo; for the password. To complete checkout flow, please enter shipping address, and for payment simply enter \u0026ldquo;FREE\u0026rdquo; in the \u0026ldquo;Promo Code\u0026rdquo; field and click \u0026ldquo;Submit Order\u0026rdquo; - if all went as planned, you should see the \u0026ldquo;Checkout Complete\u0026rdquo; message.\n"
},
{
	"uri": "/en/10-intro/30-dotnet-secrets.html",
	"title": ".NET Core Secret Manager",
	"tags": [],
	"description": "",
	"content": " An important note on using .NET Core Secret Manager:\n This lab makes an extensive use of .NET Core Secret Manager on your development workstation to save database passwords and similar types of sensitive application configuration data that varies from one developer\u0026rsquo;s workstation to another. Please note that despite the name .NET Core Secret Manager is not secure! It does not encrypt or password-protect your sensitive data. .NET Secrets are just plain text JSON files stored in a well-known directory. All they do is:\n Allow saving applications settings data outside of the project root, eliminating the risk of committing your sensitive appsettings data inadvertently, and Provide one more layer in the appsettings.json override hierarchy.  One can think of .NET Core Secret Manager as just a way to alter appsettings.json at development time, without modifying actual appsettings.json or launchsettings.json, i.e. without the risk of committing sensitive setting values into a source code repository.\n"
},
{
	"uri": "/en/20-cdk/40-creating-ci-cd-pipeline.html",
	"title": "Creating AWS CI/CD Pipeline",
	"tags": [],
	"description": "",
	"content": " Before we dive into the code base of the Unicorn Store solution and start hacking it, let\u0026rsquo;s spend a few moments and create the CI/CD pipeline infrastructure in AWS, as creating it takes a few minutes to complete, and while that is in progress, we\u0026rsquo;ll spend some time looking into the structure of the project and getting familiar with CDK concepts.\n    Notes      Again, please select either Postgres or SQL Server configuration from Solution\u0026rsquo;s Build Configuration drop-down in Visual Studio\u0026hellip;    \u0026hellip;and mark \u0026ldquo;CicdInfraAsCode\u0026rdquo; project as a startup project. Then right-click the project and select \u0026ldquo;Manage User Secrets\u0026rdquo;. That will open \u0026ldquo;secrets.json\u0026rdquo; file in the IDE editor. Replace the content of the file with:    { \u0026#34;GitBranchToBuild\u0026#34;: \u0026#34;cdk-module\u0026#34; } \u0026hellip; and save the file.\nPlease build \u0026amp; run the project. If all went well you should see a console window with output starting with something like Synthesized to \u0026ldquo;C:\\Users\\username\\AppData\\Local\\Temp\\cdk.outjLaGkJ\u0026rdquo;. That path is the location of generated CloudFormation templates. If you are familiar with CloudFormation, please feel free to explore the output of this step.\nLaunching CI/CD Pipeline Infrastructure Creation Please open a Command Prompt window and cd into the directory containing \u0026ldquo;CicdInfraAsCode.csproj\u0026rdquo; project file, which relative to the solution root is in \u0026ldquo;infra-as-code/CicdInfraAsCode/src\u0026rdquo;.\n If you never ran cdK CLI before in the currently-configured AWS Region, and you are not using an AWS event supplied VM, you may need to run cdk bootstrap command that runs a CloudFormation template that configures some resources required for the CDK to function. This is a one-time action per AWS region.\n Next, run the following command to start creation of the CI/CD pipeline infrastructure:\ncdk deploy --require-approval never That will effectively apply CloudFormation template \u0026ldquo;synthesized\u0026rdquo; when project was built and run. This CloudFormation template starts a process of creating a CI/CD pipeline infra for the application, provisioning AWS CodePipeline service, which in turn orchestrates few other AWS services, like CodeCommit and CodeBuild. This CI/CD infrastructure build-out job should take a few minutes, which will be well spent in the next section, which deals with the structure of the project.\nIf you are comfortable using AWS online Console, feel free to go to the CloudFormation service section of the Console to monitor the progress of the the CI/CD pipeline infra rollout.\n"
},
{
	"uri": "/en/20-cdk/50-project-structure.html",
	"title": "Project Structure",
	"tags": [],
	"description": "",
	"content": " Let\u0026rsquo;s use the few minutes that it takes for the application CI/CD pipeline infrastructure to build, to get familiar with the structure of the project.\n    Notes      Solution contains one ASP.NET Core application project named UnicornStore, and three CDK-related projects: CdkLib - a C# class library project, containing reusable components shared between two executable CDK projects.    The first of executable CDK projects is CicdInfraAsCode - the project we ran at the previous step of the lab. \u0026ldquo;CicdInfraAsCode\u0026rdquo; is a C# Console project, generating CloudFormation templates from C# code for building out AWS CodePipeline CI/CD infrastructure.\n The \u0026ldquo;CicdInfraAsCode\u0026rdquo; project contains a small Node.js sub-project in the \u0026ldquo;/assets/lambda/ecs-container-recycle\u0026rdquo; directory, which defines serverless AWS Lambda function used at the final stage of the CI/CD pipeline to recycle Linux containers, after new container image is built and made available to the application hosted by Amazon ECS.\n Second executable CDK project is ProdEnvInfraAsCode - an C# Console project, generating CloudFormation templates that build out Unicorn Store application deployment environment in AWS cloud. This project will not be run from the Visual Studio because it will be run from the AWS CodePipeline to deploy Unicorn Store application packaged as a Linux container to Amazon Elastic Cloud Service (ECS), and to provision an RDBMS instance for the application from Amazon Relational Database Service (RDS).\nUnicorn Store ASP.NET Core Application Overview Application Project A descendant from a well-known ASP.NET Music Store sample, Unicorn Store is created to be a fairly typical ASP.NET Core 2.x MVC/Razor \u0026amp; Entity Framework Core application, combining UI, business logic and data access tiers in a single application, which is arguably a very typical design for most ASP.NET applications pre-dating microservices, 12-factor/cloud-native applications, and as such, suitable for modernization-focused labs.\nUnicorn Store data access tier is designed using code-first style, which uses C# code to define entity relationships and consequently database structure. This approach enables relatively easy swapping of database engines without drastically affecting the codebase. This module starts with the application codebase already retrofitted with pluggable RDBMS architecture and supporting SQL Server and PostgreSQL database engines out of the box.\nThis lab\u0026rsquo;s focus is on adding support for MySQL database, which is a pretty simple task enabled by most of database engine configuration code abstracted away and already implemented. This relative simplicity will let us focus on the CDK-related tasks in later chapters.\nApplication\u0026rsquo;s Dockerfile Located in the solution\u0026rsquo;s root folder, and accessible from Visual Studio \u0026ldquo;Solution Items\u0026rdquo; folder, the Dockerfile defines how application is built and prepared for being published as a Docker container image. The Dockerfile is used by the AWS CodeBuild step of the application\u0026rsquo;s CI/CD pipeline defined in the CreateDockerImageBuildAction() method in the CicdInfraAsCode.csproj.\nCDK Projects Overview CdkLib CdkLib, a shorthand for CDK library, contains modest amount of reusable C# code referenced by both executable .NET CDK projects. It\u0026rsquo;s home to classes and helper methods reducing amount of boilerplate, making infrastructure build-out \u0026ldquo;meat\u0026rdquo; code in main projects more concise and expressive. It also serves as an illustration that CDK code is very easy to componentize and parameterize.\nOne of the most useful bits in the CdkLib project is helper methods loading standard .NET Core IConfiguration from appsettings.json, environment variables, command line args and .NET Secret Manager, and deserialized into a strongly-typed class compatible with main CDK stack setting marshalling interface. This makes it ver easy to pass parameters to CDK projects via Environment variables in CodePipeline, CodeBuild and other places.\nProdEnvInfraAsCode This project is a .NET CDK Console application project responsible for generating AWS CloudFormation templates that create Unicorn Store application hosting environment. The hosting environment, at the high level, consists of the Amazon Elastic Container Service (ECS) and Relational Database Service (RDS). Under the hood the infrastructure built by this project is more complex, including various networking components, like a load balancer, virtual private cloud, subnets, security groups (firewall rules), roles and others.\nHowever, despite the sophistication of the cloud infrastructure produced by this project, the amount and complexity of the code required to implement it is strikingly low.\n ProdEnvInfraAsCode project is going to be run by the \u0026ldquo;build\u0026rdquo; part of the CI/CD pipeline, and not manually by developers, except for debugging purposes discussed in later chapters.\n Architectural Diagram of the Application Hosting Environment CicdInfraAsCode The more complex of all CDK projects, still with only about 300 lines of CDK code (plus another 100 lines of Node.js code), this C# Console app project produces three-stage project build and deployment pipeline, show below.\nAt high level, the CI/CD pipeline infrastructure includes Amazon CodePipeline, CodeCommit - a Git repository service, CodeBuild, Elastic Container Registry (ECR), and Lambda services.\nThe Build stage of the pipeline contains two parallel sub-stages: a) building application and packaging its artifacts as a Docker container image, and b) compiling and running second CDK project, the \u0026ldquo;ProdEnvInfraAsCode\u0026rdquo;, which builds out deployment infrastructure for hosting Unicorn Store app. Having hosting infrastructure built as part of app\u0026rsquo;s CI/CD pipeline may not be suitable for putting an application in production, but it could be quite useful for deploying application to a test environment. One can easily imagine a pipeline where the test environment containing large, pricey components is short-lived: provisioned, used only for the duration of an integration suite run, and then torn down to avoid an unnecessary spend.\nThe pipeline created by the CicdInfraAsCode is not overly complicated and does not yet contain any quality gates, like testing, but it can serve as a springboard for an evolving real-world CI/CD pipeline project.\nThe project contains a Node.js sub-project in the \u0026ldquo;/src/assets/lambda/ecs-container-recycle\u0026rdquo;, which implements a serverless AWS Lambda function that is invoked by the final stage of the CI/CD pipeline to restart the ECS-hosted Unicorn Store application to load newly-minted application build.\nThe size of the Node.js code-base is fairly modest, and the code is split between the \u0026ldquo;cdklib\u0026rdquo; directory, where reusable and potentially boilerplate code is sequestered, and the \u0026ldquo;index.js\u0026rdquo; file, where the man logic of the function is implemented.\n At this point, please spend 5-10 minutes browsing through the UnicornStore solution to get familiar with where major parts of the codebase located.\n Now that we\u0026rsquo;ve taken the tour of the project, let\u0026rsquo;s move to the next chapter to see whether our CI/CD infrastructure has finished building.\n"
},
{
	"uri": "/en/20-cdk/60-starting-cicd-build.html",
	"title": "Starting Pipeline Build",
	"tags": [],
	"description": "",
	"content": " At this point the CI/CD pipeline cloud infrastructure, the build-out of which was launched two chapters back, should be completed.\nFirst, please check the command prompt console where you ran cdk deploy for the \u0026ldquo;CicdInfraAsCode\u0026rdquo; project, to make there were no errors. You should see something like the following at the tail of the output after command has finished:\n 30/30 | 1:10:43 PM | CREATE_COMPLETE | AWS::CloudFormation::Stack | Unicorn-Store-CI-CD-PipelineStack ✅ Unicorn-Store-CI-CD-PipelineStack Stack ARN: arn:aws:cloudformation:us-east-1:123456789012:stack/Unicorn-Store-CI-CD-PipelineStack/eee6e58c-6808-48a2-9885-c719f44dd8b6  Next, navigate to the CodePipeline in the AWS Console and observe \u0026ldquo;Unicorn-Store-CI-CD-Pipeline\u0026rdquo; in the list, showing the \u0026ldquo;Failed\u0026rdquo; status next to it. The pipeline is in the failed state because the source code of the Unicorn Store solution has not yet been pushed to the CodeCommit Git repository.\nPlease click on the \u0026ldquo;Unicorn-Store-CI-CD-Pipeline\u0026rdquo; link to see the brand-new pipeline: Starting the Pipeline: Pushing Source Code to CodeCommit To trigger the build and deployment pipeline, all we need to do is to push the Unicorn Store to the CodeCommit Git repository just created.\n Following step: adding Git \u0026ldquo;remote\u0026rdquo; (alias) pointing to the CodeCommit repository, can be skipped if you are taking this lab at an AWS event, as the \u0026ldquo;aws\u0026rdquo; Git remote is already created on your dev VM.\n Windows users, please use Powershell in Administrator mode for running commands that follow.\n First, cd into the root of the Unicorn Store solution. Create Git \u0026ldquo;remote\u0026rdquo; named \u0026ldquo;aws\u0026rdquo;:\ngit remote add aws (aws codecommit get-repository --repository-name Unicorn-Store-Sample-Git-Repo | jq -r .repositoryMetadata.cloneUrlHttp) Push the code to the CodeCommit repository:\ngit push aws cdk-module Wait a few moments, and then go to the AWS Console CodePipeline page to observe CodePipeline build in-progress :   First run of the pipeline is likely to take approximately 15 minutes, primarily due to time required to provision application database and ECS-based application hosting infrastructure. Subsequent pipeline runs could finish in under one minute if no changes we introduced into the CDK-based infrastructure code.\n Clicking \u0026ldquo;Details\u0026rdquo; links of each Build stage action, will show the real-time stdout/console output of the application build and hosting infrastructure build, respectively.\n The Details of the Docker image build action output shows how application is being built, and if it fails to build for whatever reason and results in the red action status, the output will provide most definitive information about causes of the issues. The same is true for the hosting/deployment infra Build step action. Even when everything builds fine, please review the Build step action outputs - that will provide a lot of insight of how both how application is build \u0026amp; deployed, and how CI/CD pipeline CDK project\u0026rsquo;s Buildspec definitions translate into actual executable commands. The usefulness of the lab module may hinge on whether you take time to review Build actions\u0026rsquo; output and connect this insight with what you learn from examining CI/CD project code.\n"
},
{
	"uri": "/en/20-cdk/63-verify-ci-cd-completion.html",
	"title": "Verify Pipeline Run Completion",
	"tags": [],
	"description": "",
	"content": " While the pipeline is busy building the application and provisioning application hosting infrastructure, we have about 15-20 minutes to start hacking the app and CDK projects, adding MySQL support to it. Because this hosting infra build-out process takes some time, please feel free to go to move on to the next chapter and come back here later to ensure the pipeline is alright.\nVerifying the CI/CD Pipeline Run Has Completed Whenever the pipeline has finished, feel free to browse to the AWS Load Balancer page in the AWS Console, select a load balancer named \u0026ldquo;unicorn-store\u0026rdquo; and click the \u0026ldquo;copy to clipboard\u0026rdquo; icon next to the \u0026ldquo;DNS Name\u0026rdquo; field.\nThen paste the URL into a new browser tab, hit Enter and observe Unicorn Application home page loaded: Verifying the Unicorn Store App Running on AWS To verify that nothing is broken, please add a few unicorns to the basket, and click the \u0026ldquo;Checkout \u0026gt;\u0026gt;\u0026rdquo; button at the top of the shopping cart page. You will be prompted to log in. Although site administrator username has not changed and remains \u0026ldquo;Administrator@test.com\u0026rdquo;, the password was not specified explicitly in the hosting environment infrastructure project configuration settings, or anywhere else for that matter. Instead, site admin password was auto-generated during the hosting infrastructure build-out and stored using Amazon Secrets Manager service.\nTo retrieve site admin password from AWS Secrets Manager, please run this command:\naws secretsmanager get-secret-value --secret-id UnicornSuperstoreDefaultSiteAdminPassword | jq -r .SecretString Copy the output of the command to the clipboard and use it as password to log in to the site.\nTo complete checkout flow, please enter any shipping address, and for payment simply enter \u0026ldquo;FREE\u0026rdquo; in the \u0026ldquo;Promo Code\u0026rdquo; field and click \u0026ldquo;Submit Order\u0026rdquo; - if all went as planned, you should see the \u0026ldquo;Checkout Complete\u0026rdquo; message.\n"
},
{
	"uri": "/en/20-cdk/65-adding-mysql-support.html",
	"title": "MySQL Support",
	"tags": [],
	"description": "",
	"content": "This chapter will guide you through the process of adding support for MySQL to the Unicorn Store application and to infra-as-code projects. MySQL is an open source, cross-platform, relational database that can be run in a cloud, on premises, or locally on developer workstation free of charge.\nThis set of steps builds on the existing, multi-database-friendly architecture of the Unicorn Store application, which already supports MS SQL Server and open-source PostgreSQL, while requiring only modest changes to the code of executable projects in the Solution.\n Although the amount of work to add C# code enabling MySQL support is fairly modest, if you\u0026rsquo;d rather not do that, feel free to fast-forward by following these steps:\n Check out cdk-module-completed Git branch, that has all required changes. Use AWS online Console to modify \u0026ldquo;Source\u0026rdquo; stage of the pipeline, by editing the Action and changing the value of the \u0026ldquo;Branch Name\u0026rdquo; field from \u0026ldquo;cdk-module\u0026rdquo; to \u0026ldquo;cdk-module-completed\u0026rdquo;. Go to the Testing CI/CD Project Changes chapter to see how to deliver changes via the CI/CD pipeline.   "
},
{
	"uri": "/en/20-cdk/67-app-nuget-and-appsettings.html",
	"title": "App: NuGet and AppSettings",
	"tags": [],
	"description": "",
	"content": "  This chapter assumes that MySQL is installed locally.\n Adding MySQL Library to the Application via NuGet  Please start with marking \u0026ldquo;UnicornStore\u0026rdquo; project as a Startup Project in Visual Studio. Open \u0026ldquo;Package Manager Console\u0026rdquo; by selecting it from the \u0026ldquo;View | Other Windows\u0026rdquo; menu. Install Pomelo.EntityFrameworkCore.MySql version 2.2 package by running following command in Visual Studio \u0026ldquo;Package Manager Console\u0026rdquo;:\nInstall-Package Pomelo.EntityFrameworkCore.MySql -Version 2.2.0  Adding Default Connection String to \u0026ldquo;appSettings.json\u0026rdquo; Open \u0026ldquo;appSettings.json\u0026rdquo; file of the \u0026ldquo;UnicornStore\u0026rdquo; project and add following entry to the \u0026ldquo;ConnectionStrings\u0026rdquo; section.\n\u0026#34;UnicornStoreMySQL\u0026#34;: \u0026#34;Server=localhost;Database=UnicornStore;Uid=root;Pwd=NeverEVERsavePasswordInConfigFiles;\u0026#34; Don\u0026rsquo;t forget the comma before or after the \u0026ldquo;UnicornStoreMySQL\u0026rdquo; property.\n"
},
{
	"uri": "/en/20-cdk/69-updating-build-config.html",
	"title": "Updating Build Config",
	"tags": [],
	"description": "",
	"content": "Now we need to update solution-to-project Build Configuration mapping.\n    Notes      Please start with bringing up Solution Configuration Manager.    Then select \u0026ldquo;DebugMySQL from the \u0026ldquo;Active solution configuration dropdown and change all executable project configuration mappings from \u0026ldquo;DebugPostgress\u0026rdquo; to \u0026ldquo;DebugMySQL\u0026rdquo;:\n           Changeto =\u0026gt;     Please do the same for the ReleaseMySQL solution configuration: map executable project context configurations to \u0026ldquo;ReleaseMySQL\u0026rdquo;\n FYI, each project that has \u0026ldquo;XxxxxMySQL\u0026rdquo; configuration, has MYSQL conditional compilation constant defined for the project: (Same is true for \u0026ldquo;XxxxxPostgres\u0026rdquo; and \u0026ldquo;XxxxxSqlServer\u0026rdquo;: they have POSTGRES and SQLSERVER respective build constants defined.)\nThe process of creating \u0026ldquo;DebugMySQL\u0026rdquo; and \u0026ldquo;ReleaseMySQL\u0026rdquo; project build configurations is tedious and not very relevant to this module\u0026rsquo;s goals, so these two project build configurations are provided out of the box, rather than guiding lab participants here to create them manually.\n Finally, please ensure DebugMySQL solution configuration is selected in the \u0026ldquo;Solution Configurations\u0026rdquo; dropdown.\n"
},
{
	"uri": "/en/20-cdk/71-modifying-startup-cs.html",
	"title": "Modifying Startup.cs",
	"tags": [],
	"description": "",
	"content": " Please open \u0026ldquo;Startup.cs\u0026rdquo; file of the \u0026ldquo;UnicornStore\u0026rdquo; project in Visual Studio. Add following line to the top part of the file:\nusing MySql.Data.MySqlClient;  Find ConfigureDatabaseEngine() method and replace the \u0026ldquo;#if POSTGRES\u0026rdquo; line in it with\n#if MYSQL  this.HookupMySQL(services); #elif POSTGRES  Now, to implement missing \u0026ldquo;HookupMySQL()\u0026rdquo; function, find the HookupPostgres() method and replace the \u0026ldquo;#if POSTGRES\u0026rdquo; line right above the function with\n#if MYSQL  private void HookupMySQL(IServiceCollection services) { #if Debug || DEBUG  // The line below is a compile-time debug feature for `docker build` outputting which database engine is hooked up #warning Using MySQL for a database #endif  this.HookupDatabase\u0026lt;MySqlConnectionStringBuilder, MySqlDbContextOptionsConfigurator\u0026gt;(services, \u0026#34;MySQL\u0026#34;); } #elif POSTGRES   \u0026ldquo;HookupMySQL()\u0026rdquo; method does two things:\n Adds compile-time output, producing a message that MySQL is the RDBMS type the project is compiled for. Registers MySQL database engine services with .NET Core IoC container (IServiceCollection), specifically it registers stock MySqlConnectionStringBuilder from the MySQL library added via NuGet, and proprietary MySqlDbContextOptionsConfigurator that we are about to implement on the next step. HookupDatabase() is a reusable method, which among a few others was written for this workshop with the aim of achieving Database Freedom, i.e. to break original application\u0026rsquo;s dependency on SQL Server and make it compatible with wide array of open source database engines, which also makes the application compatible with Amazon RDS and Aurora services.  "
},
{
	"uri": "/en/20-cdk/73-mysqldbcontextoptionsconfigurator.html",
	"title": "MySQL Options Configurator",
	"tags": [],
	"description": "",
	"content": "Each database engine supported by the Unicorn Store application needs a DbContextOptionsConfigurator subclass. \u0026ldquo;DbContextOptionsConfigurator\u0026rdquo; facilitates deferred and dynamic updating of stored database connection settings in case when connection string information stored in the \u0026ldquo;appsettings.json\u0026rdquo; file changes while the application is running.\n \u0026ldquo;DbContextOptionsConfigurator\u0026rdquo; rectifies common anti-pattern that is unfortunately used in many ASP.NET Core sample apps, which load and cache database connection string settings only once per app lifetime during the Configure() method execution, going against the design goals of the IConfiguration-based settings handling that enable dynamic app settings reloading without requiring restarting of the app.\nTo work-around this somewhat deeply ingrained anti-pattern, a small set of classes was created for this workshop, \u0026ldquo;DbContextOptionsConfigurator\u0026rdquo; being the main class.\n  In the IDE, please expand the \u0026ldquo;UnicornStore\u0026rdquo; project tree, right-click the Configuration folder, and select \u0026ldquo;Add | Class\u0026rdquo; from the context menu. For class name, enter MySqlDbContextOptionsConfigurator.cs and hit Enter. Replace generated stock content of the file with\nusing Microsoft.EntityFrameworkCore; using Microsoft.Extensions.Logging; using System.Data.Common; namespace UnicornStore.Configuration { public class MySqlDbContextOptionsConfigurator : DbContextOptionsConfigurator { public MySqlDbContextOptionsConfigurator( DbConnectionStringBuilder dbConnectionStringBuilder, ILogger\u0026lt;MySqlDbContextOptionsConfigurator\u0026gt; logger ) : base(dbConnectionStringBuilder, logger) { } public override string DbEngine =\u0026gt; \u0026#34;MySQL\u0026#34;; internal override void Configure(DbContextOptionsBuilder optionsBuilder) { base.Configure(optionsBuilder); optionsBuilder.UseMySql(this.dbConnectionStringBuilder.ConnectionString); } } }   As you have probably noticed, the only consequential line of code in the snippet above is\noptionsBuilder.UseMySql(this.dbConnectionStringBuilder.ConnectionString);  This line is the one usually called from the \u0026ldquo;Startup.cs\u0026rdquo;. Here the only thing we do differently is we defer calling UseMySql() to after \u0026ldquo;IConfiguration\u0026rdquo; become injectable, like you do it when you need \u0026ldquo;IConfiguration\u0026rdquo; in your MVC controller.\n Injecting \u0026ldquo;IConfiguration\u0026rdquo;, as it\u0026rsquo;s done in a typical MVC controller example, is the right way to use configuration settings. Manually loading connection string data, as often done in \u0026ldquo;Startup.cs\u0026rdquo;, breaks dynamic settings reload support. Mixing two mutually-exclusive approaches makes no practical sense, so we took this opportunity to make configuration settings data usage consistent across the entire ASP.NET application. Feel free to improve this logic and create a PR.\n "
},
{
	"uri": "/en/20-cdk/75-verifying-mysql-support-locally.html",
	"title": "Verifying MySQL Support",
	"tags": [],
	"description": "",
	"content": " Please be sure that \u0026ldquo;DebugMySQL\u0026rdquo; solution configuration is active. Build \u0026ldquo;UnicornStore\u0026rdquo; project - it should build without errors. Now we need to add your local MySQL connection information to the application settings in a non-destructive way, meaning without modifying \u0026ldquo;appSettings.json\u0026rdquo; or any other file in the solution root, which might lead to an inadvertent committing of credentials information to the version control system. To do this, we\u0026rsquo;ll use .NET Secret Manager. Please right-click \u0026ldquo;UnicornStore\u0026rdquo; project and select Manage User Secrets from the context menu. That will open \u0026ldquo;secrets.json\u0026rdquo; file in the IDE editor. Create or update UnicornDbConnectionStringBuilder entry in the \u0026ldquo;secrets.json\u0026rdquo; as follows\n{ \u0026quot;UnicornDbConnectionStringBuilder\u0026quot;: { \u0026quot;UserID\u0026quot;: \u0026quot;root\u0026quot;, \u0026quot;Password\u0026quot;: \u0026quot;\u0026lt;PASTE YOUR LOCAL MYSQL PASSWORD HERE\u0026gt;\u0026quot;, \u0026quot;ApplicationName\u0026quot;: \u0026quot;Unicorn Store AWS\u0026quot; } ... }   Please be sure to replace the value of the Password field with your local MySQL password and save the file. Run the \u0026ldquo;UnicornStore\u0026rdquo; project. If everything went well, you should see now-familiar Unicorn Store home page in the browser.     At the very bottom of the page you should see \u0026ldquo;MySQL database server address: localhost:3306\u0026rdquo; message. If you\u0026rsquo;ve got it, congratulations! You\u0026rsquo;ve just made this run-off-the-mill ASP.NET Core application work with a mature, multi-platform, open-source database engine, one implementation of which may give your database as much as 5x performance boost!\n "
},
{
	"uri": "/en/20-cdk/77-mysql-hosting-env-stack.html",
	"title": "Adding MySQL Support to the Hosting Env CDK Project",
	"tags": [],
	"description": "",
	"content": "  Next couple of sections will guide you through adding MySQL support to the ProdEnvInfraAsCode project that defines application cloud hosting environment using infrastructure-as-code approach.\nMySQL database underpinning Unicorn Store application is going to run in AWS cloud and is implemented either by Amazon RDS for MySQL or by Amazon Aurora service, depending whether the infrastructure is configured to run in a single-instance or in the cluster mode.\nAmazon RDS and Amazon Aurora are SQL Server, MySQL and PostgreSQL-compatible, managed, \u0026ldquo;serverless\u0026rdquo; services, capable of replacing self-managed RDBMS deployments running on unmanaged VMs or in containers. (AWS Aurora does not support SQL Server - only AWS RDS does).\n Please start by marking \u0026ldquo;ProdEnvInfraAsCode\u0026rdquo; project inside the \u0026ldquo;infra-as-code\u0026rdquo; Visual Studio folder as a \u0026ldquo;Startup Project\u0026rdquo;.\nUpdating UnicornStoreDeploymentEnvStackProps.cs \u0026ldquo;UnicornStoreDeploymentEnvStackProps.cs\u0026rdquo; file holds configuration properties used by the hosting environment CDK infra-as-code \u0026ldquo;stack\u0026rdquo;. We need to make a few changes here.\n Open the \u0026ldquo;UnicornStoreDeploymentEnvStackProps.cs\u0026rdquo; file in the IDE editor. Find the DbEngineType enum and add MySQL entry to the enum. Find the DbEngine property and replace the \u0026ldquo;#if POSTGRES\u0026rdquo; line with\n#if MYSQL  DbEngineType.MySQL; #elif POSTGRES  Find the CreateDbConstructFactory() method and add the following to the top of the switch statement:\ncase DbEngineType.MySQL: return new MySqlConstructFactory(this);  At this point the only error on this page will be undefined MySqlConstructFactory() constructor from the class that will be implemented in the section below.\n  Implementing MySqlConstructFactory Class  Right-click Reusable folder under the \u0026ldquo;ProdEnvInfraAsCode\u0026rdquo; project in Visual Studio and select \u0026ldquo;Add | Class\u0026rdquo; from the context menu. For the class name, enter MySqlConstructFactory.cs and hit Enter. Replace generated stock implementation with\nusing Amazon.CDK.AWS.RDS; namespace ProdEnvInfraAsCode.Reusable { public class MySqlConstructFactory : DatabaseConstructFactory { public MySqlConstructFactory(UnicornStoreDeploymentEnvStackProps settings) :base(settings) { } protected override DatabaseInstanceEngine DbInstanceEgnine =\u0026gt; DatabaseInstanceEngine.MYSQL; protected override DatabaseClusterEngine DbClusterEgnine =\u0026gt; base.DbClusterEgnine ?? DatabaseClusterEngine.AURORA_MYSQL; protected override string ExistingAuroraDbParameterGroupName =\u0026gt; \u0026#34;default.aurora-mysql5.7\u0026#34;; internal override string DBConnStrBuilderUserPropName =\u0026gt; \u0026#34;UserID\u0026#34;; } }  This class above supplies four settings for a handful of AWS RDS infrastructure settings:\n DatabaseInstanceEngine.MYSQL for the database instance engine, i.e. for when RDS service runs in a single-instance mode, as opposed to the cluster mode. DatabaseClusterEngine.AURORA_MYSQL for the database cluster engine, i.e. when RDS service runs in a cluster mode, and not in the single-instance mode. \u0026ldquo;default.aurora-mysql5.7\u0026rdquo; as a name of setting set known as a Parameter Group. Parameter Groups are maintained by AWS and are organized in a handful of pre-defined, named parameter sets made available to infrastructure builders. Here we select a most common, default set of parameters for the RDS MySQL. \u0026ldquo;UserID\u0026rdquo; here is the name of the property defining database user/login name in the Connection String Builder subclass for a specific database engine type. Here it means that for MySQL, Connection String Builder property carrying database username is called \u0026ldquo;UserID\u0026rdquo;.    As you can see, \u0026ldquo;MySqlConstructFactory\u0026rdquo; pretty much in its entirety simply serves up a few overrides to the \u0026ldquo;DatabaseConstructFactory\u0026rdquo; base class, driving a few changes in how Unicorn Store database in AWS RDS is going to be configured.\n Verifying ProdEnvInfraAsCode Project Run the \u0026ldquo;ProdEnvInfraAsCode\u0026rdquo; project an ensure it did not throw any exceptions. The output is the CloudFormation template that can be used to provision Unicorn Store application hosting infrastructure.\n"
},
{
	"uri": "/en/20-cdk/79-mysql-ci-cd-stack.html",
	"title": "MySQL in CI/CD CDK Project",
	"tags": [],
	"description": "",
	"content": " Here we\u0026rsquo;ll add MySQL support to the CI/CD CDK project.\n  Please start with marking \u0026ldquo;CicdInfraAsCode\u0026rdquo; project as a \u0026ldquo;Startup Project\u0026rdquo; in Visual Studio. Open \u0026ldquo;UnicornStoreCiCdStackProps.cs\u0026rdquo; file in the IDE editor. Find the DbEngineType enum and add MySQL entry to it. Find the DbEngine property and replace the \u0026ldquo;#if POSTGRES\u0026rdquo; line with\n#if MYSQL  DbEngineType.MySQL; #elif POSTGRES   This is it, that\u0026rsquo;s all the changes we needed to make to the CI/CD CDK project to add MySQL database support.\n"
},
{
	"uri": "/en/20-cdk/80-verifying-cicd-project-changes.html",
	"title": "Testing CI/CD Changes",
	"tags": [],
	"description": "",
	"content": " Run the CicdInfraAsCode project from the IDE to ensure there are no exceptions thrown. Open Command Prompt window and cd to the root of the \u0026ldquo;CicdInfraAsCode\u0026rdquo; project. Run cdk diff - command that compares currently-provisioned AWS infrastructure (of the CI/CD pipeline in this case) and created earlier by the infra-as-code \u0026ldquo;stack\u0026rdquo;, with the infrastructure modified by the changes to the project codebase. You should see output looking like\nSynthesized to \u0026quot;cdk.out\u0026quot;. Stack Unicorn-Store-CI-CD-PipelineStack The Unicorn-Store-CI-CD-PipelineStack stack uses assets, which are currently not accounted for in the diff output! See https://github.com/aws/aws-cdk/issues/395 Resources [~] AWS::CodeBuild::Project CodeBuildProject CodeBuildProject4B91CF3F └─ [~] Environment └─ [~] .EnvironmentVariables: └─ @@ -54,7 +54,7 @@ [ ] { [ ] \u0026quot;Name\u0026quot;: \u0026quot;DbEngine\u0026quot;, [ ] \u0026quot;Type\u0026quot;: \u0026quot;PLAINTEXT\u0026quot;, [-] \u0026quot;Value\u0026quot;: \u0026quot;Postgres\u0026quot; [+] \u0026quot;Value\u0026quot;: \u0026quot;MySQL\u0026quot; [ ] }, [ ] { [ ] \u0026quot;Name\u0026quot;: \u0026quot;BuildConfig\u0026quot;, @@ -64,6 +64,6 @@ [ ] { [ ] \u0026quot;Name\u0026quot;: \u0026quot;ImageTag\u0026quot;, [ ] \u0026quot;Type\u0026quot;: \u0026quot;PLAINTEXT\u0026quot;, [-] \u0026quot;Value\u0026quot;: \u0026quot;Postgres\u0026quot; [+] \u0026quot;Value\u0026quot;: \u0026quot;MySQL\u0026quot; [ ] } [ ] ] [~] AWS::CodeBuild::Project DeploymentEnvCreationProject DeploymentEnvCreationProject70D82E6D └─ [~] Environment └─ [~] .EnvironmentVariables: └─ @@ -2,7 +2,7 @@ [ ] { [ ] \u0026quot;Name\u0026quot;: \u0026quot;DbEngine\u0026quot;, [ ] \u0026quot;Type\u0026quot;: \u0026quot;PLAINTEXT\u0026quot;, [-] \u0026quot;Value\u0026quot;: \u0026quot;Postgres\u0026quot; [+] \u0026quot;Value\u0026quot;: \u0026quot;MySQL\u0026quot; [ ] },  Please note parts reflecting the RDBMS type change in the output above:\n [-] \u0026quot;Value\u0026quot;: \u0026quot;Postgres\u0026quot; [+] \u0026quot;Value\u0026quot;: \u0026quot;MySQL\u0026quot;   cdk diff is a very, very useful command, allowing developers to build-out an infrastructure base line, and then make changes to the infra-as-code project code and run \u0026ldquo;cdk diff\u0026rdquo; to see what will be changed in the cloud infrastructure if they run \u0026ldquo;cdk deploy\u0026rdquo;. That provides fast and non-destructive way of understanding what changes in the the infra-as-code project will be made by corresponding changes in the CDK project.\n Run \u0026ldquo;cdk deploy --require-approval never\u0026rdquo; and it should complete in a minute or two without errors, updating the CI/CD pipeline infrastructure in AWS with MySQL configured as the database engine.\n Now we need to trigger the pipeline by committing and pushing code changes to the AWS CodeCommit. For that please run following commands from the root directory of the Solution:\ngit add . git commit -m \u0026#34;Added MySQL support\u0026#34; git push aws In a few moments you should see the CI/CD pipeline running.\n   Since hosting environment \u0026ldquo;stack\u0026rdquo; will now need to replace PostgreSQL database with MySQL database, it will again take roughly 15 minutes to complete the transition. Please keep monitoring the state of the pipeline, and once it finishes, please verify everything is well by using these steps.\nAnother important point: switching from Postgres to MySQL does not transfer data from Postgres to MySQL. All data stored in the Postgres database will be lost, and an empty MySQL database will be crated.\n "
},
{
	"uri": "/en/20-cdk/81-explore-cdk-stack-source.html",
	"title": "Explore CDK Stack Source",
	"tags": [],
	"description": "",
	"content": " Now it\u0026rsquo;s perfect time to take a look at how a CDK \u0026ldquo;stack\u0026rdquo; written in C# looks like.\nFor best experience, please mark \u0026ldquo;ProdEnvInfraAsCode\u0026rdquo; as a Startup Project, open its \u0026ldquo;Program.cs\u0026rdquo; in the IDE editor, put a break on the line with the `new UnicornStoreFargateStack(\u0026hellip;)\u0026rdquo; and start debugging.\nFirst you will skip over the straightforward-sounding LoadConfiguration() method that reads in \u0026ldquo;appSettings.json\u0026rdquo; etc. and passes loaded data to the UnicornStoreFargateStack(...) constructor in the settings variable.\nNext, with the debugger, step into the \u0026ldquo;UnicornStoreFargateStack(\u0026hellip;)\u0026rdquo; constructor. That\u0026rsquo;s where the highest-level flow creating Unicorn Store application hosting environment in its entirety is defined.\n Please use the debugger to step inside every method you can in this project - it will only take five minutes or so to do that, but it will provide more insight into what CDK is all about than most of the \u0026ldquo;Hello, World\u0026rdquo; type of examples. This project is still pretty small in terms of code line count, but it provisions really sophisticated hosting environment.\nThe exercise of stepping through this project using debugger may be the most valuable activity of the entire Workshop.\n For those not inclined to step-debug through the code, here\u0026rsquo;s the screenshot of the main logic orchestrating application hosting environment creation at the highest level.\nIf you have experience with CloudFormation, you likely will appreciate ability to use imperative and object-oriented features of a real programming language, which may provision different resources depending on the execution path dictated by configuration settings.\nCool CDK Feature Worth Noting: Packaging Runtime Dependencies For many infra-as-code use cases, a CloudFormation template defining the infrastructure is not the only thing required. Very often additional run-time components are necessary. Lambda functions is likely a most common run-time dependency for a \u0026ldquo;stack\u0026rdquo;. In our case, the final stage of the CI/CD pipeline employs a Lambda function, (which in reality is a small Node.js project) that runs to recycle the application and re-load it from the image containing latest changes. Lambda code, however, does not get embedded into the generated CloudFormation template - it lives outside and instead is referenced by the it.\nThe above means that we have a choice of keeping the Lambda function in a separate source code repository if we want to, but it makes much more sense to keep it within the CDK project. But how will one make generated CloudFormation template reference the Node.js artifact? If you used other infra-as-code tools, you may have run into a situation where you had to make your infra-as-code project aware of its own Git location to let is reference additional runtime dependency components from the same repo. To avoid this awkward self-referencing, CDK allows packaging of several types of artifacts right from the project source itself.\nIn this project, the CreateLambdaForRestartingEcsApp() method has this line:\nCode = Code.FromAsset(\u0026#34;assets/lambda/ecs-container-recycle\u0026#34;)  The magic it performs allows keeping stack-specific lambda code right here in the same Git repository, and references this lambda in the way that avoids awkward self-referencing of the Git repo.\nLambdas is not the only type of external dependencies that can be embedded into the CDK project to package runtime artifacts and reference them from generated CloudFormation templates.\n"
},
{
	"uri": "/en/20-cdk/95-thank-you.html",
	"title": "Thank You!",
	"tags": [],
	"description": "",
	"content": "This concludes the CDK module of the workshop. Thank you very much for your participation! We hope you have learned something new and useful today, and would not mind to let us know what we could improve.\nWe encourage participants to explore the codebase of all CDK projects in this lab further to better understand the ins and outs of how to start building your own AWS infrastructure using all great features of C#.\n Please don\u0026rsquo;t forget to clean up AWS resources created in the course of this lab! Doing that is especially important if you are using personal or corporate AWS Account, to ensure no unexpected charges are made for resources you have created.\n "
},
{
	"uri": "/en/20-cdk/99-cleanup.html",
	"title": "Cleanup",
	"tags": [],
	"description": "",
	"content": " Some manual clean up steps are required to delete resources created in the course of this module. You may need to follow these steps if you used your personal or corporate AWS Account.\nYou will also need to use these steps if you are taking this lab at an AWS event and you simply want to reset your cloud resources and restart the module from the beginning.\n When using your personal or corporate AWS Account, leaving resources created by this lab will result in recurring monthly charges for used resources.\nCommands below may remove most of the resources (no guarantees though) created in the course of this module.\n Delete Infrastructure \u0026ldquo;Stacks\u0026rdquo; Created by CDK Projects To see how CDK could be leveraged for cleanup, open a Command Prompt window and cd to the root of the \u0026ldquo;CicdInfraAsCode\u0026rdquo; project. Here run\ncdk destroy to effectively delete the CloudFormation stack produced by the project, which in turn destroys AWS resources comprising our CI/CD pipeline.\nAs an alternative, you may run\naws cloudformation delete-stack --stack-name Unicorn-Store-CI-CD-PipelineStack Since hosting environment stack was run as part of the CI/CD pipeline, deleting it is easily done with deleting the corresponding CloudFormation stack:\naws cloudformation delete-stack --stack-name UnicornSuperstoreStack Although both commands return instantaneously, the process of deleting resources up to 10 minutes, give or take. To see the progress, please browse to CloudFormation -\u0026gt; Stacks in AWS Console. There you should see DELETE_IN_PROGRESS status next to \u0026ldquo;UnicornSuperstoreStack\u0026rdquo; and \u0026ldquo;Unicorn-Store-CI-CD-PipelineStack\u0026rdquo; items. Refresh the page periodically using the round arrow icon.\nDelete ECR Docker Image Repository aws ecr delete-repository --repository-name unicorn-store-app --force"
},
{
	"uri": "/en/categories.html",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/en/tags.html",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]